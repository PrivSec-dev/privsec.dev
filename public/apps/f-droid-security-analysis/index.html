<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>F-Droid Security Analysis | PrivSec.dev</title><meta name=keywords content="software,android,security"><meta name=description content="F-Droid is a popular alternative app repository for Android, especially known for its main repository dedicated to free and open-source software. F-Droid is often recommended among security and privacy enthusiasts, but how does it stack up against Play Store in practice? This write-up will attempt to emphasize major security issues with F-Droid that you should consider.
Before we start, a few things to keep in mind:
The main goal of this write-up was to inform users so they can make responsible choices, not to trash someone else&rsquo;s work."><meta name=author content="Wonderfall"><link rel=canonical href=https://wonderfall.dev/fdroid-issues><link crossorigin=anonymous href=/assets/css/stylesheet.8b523f1730c922e314350296d83fd666efa16519ca136320a93df674d00b6325.css integrity="sha256-i1I/FzDJIuMUNQKW2D/WZu+hZRnKE2MgqT32dNALYyU=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://privsec.dev/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://privsec.dev/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://privsec.dev/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://privsec.dev/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://privsec.dev/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="F-Droid Security Analysis"><meta property="og:description" content="F-Droid is a popular alternative app repository for Android, especially known for its main repository dedicated to free and open-source software. F-Droid is often recommended among security and privacy enthusiasts, but how does it stack up against Play Store in practice? This write-up will attempt to emphasize major security issues with F-Droid that you should consider.
Before we start, a few things to keep in mind:
The main goal of this write-up was to inform users so they can make responsible choices, not to trash someone else&rsquo;s work."><meta property="og:type" content="article"><meta property="og:url" content="https://privsec.dev/apps/f-droid-security-analysis/"><meta property="article:section" content="apps"><meta name=twitter:card content="summary"><meta name=twitter:title content="F-Droid Security Analysis"><meta name=twitter:description content="F-Droid is a popular alternative app repository for Android, especially known for its main repository dedicated to free and open-source software. F-Droid is often recommended among security and privacy enthusiasts, but how does it stack up against Play Store in practice? This write-up will attempt to emphasize major security issues with F-Droid that you should consider.
Before we start, a few things to keep in mind:
The main goal of this write-up was to inform users so they can make responsible choices, not to trash someone else&rsquo;s work."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Applications","item":"https://privsec.dev/apps/"},{"@type":"ListItem","position":3,"name":"F-Droid Security Analysis","item":"https://privsec.dev/apps/f-droid-security-analysis/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"F-Droid Security Analysis","name":"F-Droid Security Analysis","description":"F-Droid is a popular alternative app repository for Android, especially known for its main repository dedicated to free and open-source software. F-Droid is often recommended among security and privacy enthusiasts, but how does it stack up against Play Store in practice? This write-up will attempt to emphasize major security issues with F-Droid that you should consider.\nBefore we start, a few things to keep in mind:\nThe main goal of this write-up was to inform users so they can make responsible choices, not to trash someone else\u0026rsquo;s work.","keywords":["software","android","security"],"articleBody":"F-Droid is a popular alternative app repository for Android, especially known for its main repository dedicated to free and open-source software. F-Droid is often recommended among security and privacy enthusiasts, but how does it stack up against Play Store in practice? This write-up will attempt to emphasize major security issues with F-Droid that you should consider.\nBefore we start, a few things to keep in mind:\nThe main goal of this write-up was to inform users so they can make responsible choices, not to trash someone else’s work. I have respect for any work done in the name of good intentions. Likewise, please don’t misinterpret the intentions of this article. You have your own reasons for using open-source or free/libre/whatever software which won’t be discussed here. A development model shouldn’t be an excuse for bad practices and shouldn’t lure you into believing that it can provide strong guarantees it cannot. A lot of information in this article is sourced from official and trusted sources, but you’re welcome to do your own research. These analyses do not account for threat models and personal preferences. As the author of this article, I’m only interested in facts and not ideologies. This is not an in-depth security review, nor is it exhaustive.\n1. The trusted party problem To understand why this is a problem, you’ll have to understand a bit about F-Droid’s architecture, the things it does very differently from other app repositories, and the Android platform security model (some of the issues listed in this article are somewhat out of the scope of the OS security model, but the majority is).\nUnlike other repositories, F-Droid signs all the apps in the main repository with its own signing keys (unique per app) at the exception of the very few reproducible builds. A signature is a mathematical scheme that guarantees the authenticity of the applications you download. Upon the installation of an app, Android pins the signature across the entire OS (including user profiles): that’s what we call a trust-on-first-use model since all subsequent updates of the app must have the corresponding signature to be installed.\nNormally, the developer is supposed to sign their own app prior to its upload on a distribution channel, whether that is a website or a traditional repository (or both). You don’t have to trust the source (usually recommended by the developer) except for the first installation: future updates will have their authenticity cryptographically guaranteed. The issue with F-Droid is that all apps are signed by the same party (F-Droid) which is also not the developer. You’re now adding another party you’ll have to trust since you still have to trust the developer anyway, which isn’t ideal: the fewer parties, the better.\nOn the other hand, Play Store now manages the app signing keys too, as Play App Signing is required for app bundles which are required for new apps since August 2021. These signing keys can be uploaded or automatically generated, and are securely stored by Google Cloud Key Management Service. It should be noted that the developer still has to sign the app with an upload key so that Google can verify its authenticity before signing it with the app signing key. For apps created before August 2021 that may have not opted in Play App Signing yet, the developer still manages the private key and is responsible for its security, as a compromised private key can allow a third party to sign and distribute malicious code.\nF-Droid requires that the source code of the app is exempt from any proprietary library or ad service, according to their inclusion policy. Usually, that means that some developers will have to maintain a slightly different version of their codebase that should comply with F-Droid’s requirements. Besides, their “quality control” offers close to no guarantees as having access to the source code doesn’t mean it can be easily proofread. Saying Play Store is filled with malicious apps is beyond the point: the false sense of security is a real issue. Users should not think of the F-Droid main repository as free of malicious apps, yet unfortunately many are inclined to believe this.\nBut… can’t I just trust F-Droid and be done with it?\nYou don’t have to take my word for it: they openly admit themselves it’s a very basic process relying on badness enumeration (this doesn’t work by the way) which consists in a few scripts scanning the code for proprietary blobs and known trackers. You are therefore not exempted from trusting upstream developers and it goes for any repository.\nA tempting idea would be to compare F-Droid to the desktop Linux model where users trust their distribution maintainers out-of-the-box (this can be sane if you’re already trusting the OS anyway), but the desktop platform is intrinsically chaotic and heterogeneous for better and for worse. It really shouldn’t be compared to the Android platform in any way.\nWhile we’ve seen that F-Droid controls the signing servers (much like Play App Signing), F-Droid also fully controls the build servers that run the disposable VMs used for building apps. And as of July 2022, their guest VM image officially runs a version of Debian which reached EOL. Undoubtedly, this raises questions about their whole infrastructure security.\nHow can you be sure that the app repository can be held to account for the code it delivers?\nF-Droid’s answer, interesting yet largely unused, is build reproducibility. While deterministic builds are a neat idea in theory, it requires the developer to make their toolchain match with what F-Droid provides. It’s additional work on both ends sometimes resulting in apps severely lagging behind in updates, so reproducible builds are not as common as we would have wanted. It should be noted that reproducible builds in the main repository can be exclusively developer-signed.\nGoogle’s approach is code transparency for app bundles, which is a simple idea addressing some of the concerns with Play App Signing. A JSON Web Token (JWT) signed by a key private to the developer is included in the app bundle before its upload to Play Store. This token contains a list of DEX files and native .so libraries and their hashes, allowing end-users to verify that the running code was built and signed by the app developer. Code transparency has known limitations, however: not all resources can be verified, and this verification can only be done manually since it’s not part of the Android platform itself (so requiring a code transparency file cannot be enforced by the OS right now). Despite its incompleteness, code transparency is still helpful, easy to implement, and thus something we should see more often as time goes by.\nWhat about other app repositories such as Amazon?\nTo my current knowledge, the Amazon Appstore has always been wrapping APKs with their own code (including their own trackers), and this means they were effectively resigning submitted APKs.\nIf you understood correctly the information above, Google can’t do this for apps that haven’t opted in Play App Signing. As for apps concerned by Play App Signing, while Google could technically introduce their own code like Amazon, they wouldn’t do that without telling about it since this will be easily noticeable by the developer and more globally researchers. They have other means on the Android app development platform to do so. Believing they won’t do that based on this principle is not a strong guarantee, however: hence the above paragraph about code transparency for app bundles.\nHuawei AppGallery seems to have a similar approach to Google, where submitted apps could be developer-signed, but newer apps will be resigned by Huawei.\n2. Slow and irregular updates Since you’re adding one more party to the mix, that party is now responsible for delivering proper builds of the app: it’s a common thing among traditional Linux distributions and their packaging system. They have to catch up with upstream on a regular basis, but very few do it well (Arch Linux comes to my mind). Others, like Debian, prefer making extensive downstream changes and delivering security fixes for a subset of vulnerabilities assigned to a CVE (yeah, it’s as bad as it sounds, but that’s another topic).\nNot only does F-Droid require specific changes for the app to comply with its inclusion policy, which often leads to more maintenance work, it also has a rather strange way of triggering new builds. Part of its build process seems to be automated, which is the least you could expect. Now here’s the thing: app signing keys are on an air-gapped server (meaning it’s disconnected from any network, at least that’s what they claim: see their recommendations for reference), which forces an irregular update cycle where a human has to manually trigger the signing process. It is far from an ideal situation, and you may argue it’s the least to be expected since by entrusting all the signing keys to one party, you could also introduce a single point of failure. Should their system be compromised (whether from the inside or the outside), this could lead to serious security issues affecting plenty of users.\nThis is one of the main reasons why Signal refused to support the inclusion of a third-party build in the F-Droid official repository. While this GitHub issue is quite old, many points still hold true today.\nConsidering all this, and the fact that their build process is often broken using outdated tools, you have to expect far slower updates compared to a traditional distribution system. Slow updates mean that you will be exposed to security vulnerabilities more often than you should’ve been. It would be unwise to have a full browser updated through the F-Droid official repository, for instance. F-Droid third-party repositories somewhat mitigate the issue of slow updates since they can be managed directly by the developer. It isn’t ideal either as you will see below.\n3. Low target API level (SDK) for client \u0026 apps SDK stands for Software Development Kit and is the collection of software to build apps for a given platform. On Android, a higher SDK level means you’ll be able to make use of modern API levels of which each iteration brings security and privacy improvements. For instance, API level 31 makes use of all these improvements on Android 12.\nAs you may already know, Android has a strong sandboxing model where each application is sandboxed. You could say that an app compiled with the highest API level benefits from all the latest improvements brought to the app sandbox; as opposed to outdated apps compiled with older API levels, which have a weaker sandbox.\n# b/35917228 - /proc/misc access # This will go away in a future Android release allow untrusted_app_25 proc_misc:file r_file_perms; # Access to /proc/tty/drivers, to allow apps to determine if they # are running in an emulated environment. # b/33214085 b/33814662 b/33791054 b/33211769 # https://github.com/strazzere/anti-emulator/blob/master/AntiEmulator/src/diff/strazzere/anti/emulator/FindEmulator.java # This will go away in a future Android release allow untrusted_app_25 proc_tty_drivers:file r_file_perms; This is a mere sample of the SELinux exceptions that have to be made on older API levels so that you can understand why it matters.\nIt turns out the official F-Droid client doesn’t care much about this since it lags behind quite a bit, targeting the API level 25 (Android 7.1) of which some SELinux exceptions were shown above. As a workaround, some users recommended third-party clients such as Foxy Droid or Aurora Droid. While these clients might be technically better, they’re poorly maintained for some, and they also introduce yet another party to the mix. Droid-ify (recently rebreanded to Neo-Store) seems to be a better option than the official client in most aspects.\nFurthermore, F-Droid doesn’t enforce a minimum target SDK for the official repository. Play Store does that quite aggressively for new apps and app updates:\nSince August 2021, Play Store requires new apps to target at least API level 30. Since November 2021, existing apps must at least target API level 30 for updates to be submitted. While it may seem bothersome, it’s a necessity to keep the app ecosystem modern and healthy. Here, F-Droid sends the wrong message to developers (and even users) because they should care about it, and this is why many of us think it may be even harmful to the FOSS ecosystem. Backward compatibility is often the enemy of security, and while there’s a middle-ground for convenience and obsolescence, it shouldn’t be exaggerated. As a result of this philosophy, the main repository of F-Droid is filled with obsolete apps from another era, just for these apps to be able to run on the more than ten years old Android 4.0 Ice Cream Sandwich. Let’s not make the same mistake as the desktop platforms: instead, complain to your vendors for selling devices with no decent OS/firmware support.\nThere is little practical reason for developers not to increase the target SDK version (targetSdkVersion) along with each Android release. This attribute matches the version of the platform an app is targeting, and allows access to modern improvements, rules and features on a modern OS. The app can still ensure backwards compatibility in such a way that it can run on older platforms: the minSdkVersion attribute informs the system about the minimum API level required for the application to run. Setting it too low isn’t practical though, because this requires having a lot of fallback code (most of it is handled by common libraries) and separate code paths.\nAt the time of writing:\nAndroid 9 is the oldest Android version that is getting security updates. ~80% of the Android devices used in the world are at least running 8.0 Oreo. Overall statistics do not reflect real-world usage of a given app (people using old devices are not necessarily using your app). If anything, it should be viewed as an underestimation.\n4. General lack of good practices The F-Droid client allows multiple repositories to coexist within the same app. Many of the issues highlighted above were focused on the main official repository which most of the F-Droid users will use anyway. However, having other repositories in a single app also violates the security model of Android which was not designed for this at all. The OS expects you to trust an app repository as a single source of apps, yet F-Droid isn’t that by design as it mixes several repositories in one single app. This is important because the OS management APIs and features (such as UserManager) are not meant for this and see F-Droid as a single source, so you’re trusting the app client to not mess up far more than you should, especially when the privileged extension comes into the picture. This is also a problem with the OS first-party source feature.\nOn that note, it is also worth noting the repository metadata format isn’t properly signed by lacking whole-file signing and key rotation. Their index v1 format uses JAR signing with jarsigner, which has serious security flaws. It seems that work is in progress on a v2 format with support for apksigner, although the final implementation remains to be seen. This just seems to be an over-engineered and flawed approach since better suited tools such as signify could be used to sign the metadata JSON.\nAs a matter of fact, the new unattended update API added in API level 31 (Android 12) that allows seamless app updates for app repositories without privileged access to the system (such an approach is not compatible with the security model) won’t work with F-Droid “as is”. It should be mentioned that the aforementioned third-party client Neo-Store supports this API, although the underlying issues about the F-Droid infrastructure largely remain. Indeed, this secure API allowing for unprivileged unattended updates not only requires for the app repository client to target API level 31, but the apps to be updated also have to at least target API level 29.\nTheir client also lacks TLS certificate pinning, unlike Play Store which improves security for all connections to Google (they generally use a limited set of root CAs including their own). Certificate pinning is a way for apps to increase the security of their connection to services by providing a set of public key hashes of known-good certificates for these services instead of trusting pre-installed CAs. This can avoid some cases where an interception (man-in-the-middle attack) could be possible and lead to various security issues considering you’re trusting the app to deliver you other apps.\nIt is an important security feature that is also straightforward to implement using the declarative network security configuration available since Android 7.0 (API level 24). See how GrapheneOS pins both root and CA certificates in their app repository client:\napps.grapheneos.org C5+lpZ7tcVwmwQIMcRtPbsQtWLABXhQzejna0wHFr8M= diGVwiVYbubAI3RW4hB9xU8e/CH2GnkuvVFZE8zmgzI= jQJTbIh0grw0/1TkHSumWb+Fs0Ggogr621gT3PvPKG0= J2/oqMTsdhFWW/n85tys6b4yDBtb6idZayIEBx7QTxA= ... To be fair, they’ve thought several times about adding certificate pinning to their client at least for the default repositories. Relics of preliminary work can even be found in their current codebase, but it’s unfortunate that they haven’t been able to find any working implementation so far. Given the overly complex nature of F-Droid, that’s largely understandable.\nF-Droid also has a problem regarding the adoption of new signature schemes as they held out on the v1 signature scheme (which was horrible and deprecated since 2017) until they were forced by Android 11 requirements to support the newer v2/v3 schemes (v2 was introduced in Android 7.0). Quite frankly, this is straight-up bad, and signing APKs with GPG is no better considering how bad PGP and its reference implementation GPG are (even Debian is trying to move away from it). Ideally, F-Droid should fully move on to newer signature schemes, and should completely phase out the legacy signature schemes which are still being used for some apps and metadata.\n5. Confusing UX It is worth mentioning that their website has (for some reason) always been hosting an outdated APK of F-Droid, and this is still the case today, leading to many users wondering why they can’t install F-Droid on their secondary user profile (due to the downgrade prevention enforced by Android). “Stability” seems to be the main reason mentioned on their part, which doesn’t make sense: either your version isn’t ready to be published in a stable channel, or it is and new users should be able to access it easily.\nF-Droid should enforce the approach of prefixing the package name of their alternate builds with org.f-droid for instance (or add a .fdroid suffix as some already have). Building and signing while reusing the package name (application ID) is bad practice as it causes signature verification errors when some users try to update/install these apps from other sources, even directly from the developer. That is again due to the security model of Android which enforces a signature check when installing app updates (or installing them again in a secondary user profile). Note that this is going to be an issue with Play App Signing as well, and developers are encouraged to follow this approach should they intend to distribute their apps through different distribution channels.\nThis results in a confusing user experience where it’s hard to keep track of who signs each app, and from which repository the app should be downloaded or updated.\n6. Misleading permissions approach F-Droid shows a list of the low-level permissions for each app: these low-level permissions are usually grouped in the standard high-level permissions (Location, Microphone, Camera, etc.) and special toggles (nearby Wi-Fi networks, Bluetooth devices, etc.) that are explicitly based on a type of sensitive data. While showing a list of low-level permissions could be useful information for a developer, it’s often a misleading and inaccurate approach for the end-user. Since Android 6, apps have to request the standard permissions at runtime and do not get them simply by being installed, so showing all the “under the hood” permissions without proper context is not useful and makes the permission model unnecessarily confusing.\nF-Droid claims that these low-level permissions are relevant because they support Android 5.1+, meaning they support very outdated versions of Android where apps could have install-time permissions. Anyway, if a technical user wants to see all the manifest permissions for some reason, then they can access the app manifest pretty easily (in fact, exposing the raw manifest would be less misleading). But this is already beyond the scope of this article because anyone who cares about privacy and security wouldn’t run a 8 years old version of Android that has not received security updates for years.\nTo clear up confusion: even apps targeting an API level below 23 (Android 5.1 or older) do not have permissions granted at install time on modern Android, which instead displays a legacy permission grant dialog. Whether or not permissions are granted at install time does not just depend on the app’s targetSdkVersion. And even if this were the case, the OS package installer on modern Android would’ve been designed to show the requested permissions for those legacy apps.\nFor example, the low-level permission RECEIVE_BOOT_COMPLETED is referred to in F-Droid as the run at startup description, when in fact this permission is not needed to start at boot and just refers to a specific time broadcasted by the system once it finishes booting, and is not about background usage (though power usage may be a valid concern). To be fair, these short summaries used to be provided by the Android documentation years ago, but the permission model has drastically evolved since then and most of them aren’t accurate anymore.\nAllows the app to have itself started as soon as the system has finished booting. This can make it take longer to start the phone and allow the app to slow down the overall phone by always running.\nIn modern Android, the background restriction toggle is what really provides the ability for apps to run in the background. Some low-level permissions don’t even have a security/privacy impact and shouldn’t be misinterpreted as having one. Anyhow, you can be sure that each dangerous low-level permission has a high-level representation that is disabled by default and needs to be granted dynamically to the app (by a toggle or explicit user consent in general).\nAnother example to illustrate the shortcomings of this approach would be the QUERY_ALL_PACKAGES low-level permission, which is referred to as the query all packages permission that “allows an app to see all installed packages”. While this is somewhat correct, this can also be misleading: apps do not need QUERY_ALL_PACKAGES to list other apps within the same user profile. Even without this permission, some apps are visible automatically (visibility is restricted by default since Android 11). If an app needs more visibility, it will declare a element in its manifest file: in other words, QUERY_ALL_PACKAGES is only one way to achieve visibility. Again, this goes to show low-level manifest permissions are not intended to be interpreted as high-level permissions the user should fully comprehend.\nMoreover, Play Store restricts the use of highly invasive permissions such as MANAGE_EXTERNAL_STORAGE which allows apps to opt out of scoped storage if they can’t work with more privacy friendly approaches (like a file explorer). Apps that can’t justify their use of this permission (which again has to be granted dynamically) may be removed from Play Store. This is where an app repository can actually be useful in their review process to protect end-users from installing poorly made apps that might compromise their privacy. Not that it matters much if these apps target very old API levels that are inclined to require invasive permissions in the first place…\nConclusion: what should you do? So far, you have been presented with referenced facts that are easily verifiable. In the next part, I’ll allow myself to express my own thoughts and opinions. You’re free to disagree with them, but don’t let that overshadow the rest.\nWhile some improvements could easily be made, I don’t think F-Droid is in an ideal situation to solve all of these issues because some of them are inherent flaws in their architecture. I’d also argue that their core philosophy is not aligned with some security principles expressed in this article. In any case, I can only wish for them to improve since they’re one of the most popular alternatives to commercial app repositories, and are therefore trusted by a large userbase.\nF-Droid is often seen as the only way to get and support open-source apps: that is not the case. Sure, F-Droid could help you in finding FOSS apps that you wouldn’t otherwise have known existed. Many developers also publish their FOSS apps on the Play Store or their website directly. Most of the time, releases are available on GitHub, which is great since each GitHub releases page has an Atom feed. If downloading APKs from regular websites, you can use apksigner to validate the authenticity by comparing the certificate fingerprint against the fingerprint from another source (it wouldn’t matter otherwise).\nThis is how you may proceed to get the app certificate:\napksigner verify --print-certs --verbose myCoolApp.apk Also, as written above: the OS pins the app signature (for all profiles) upon installation, and enforces signature check for app updates. In practice, this means the source doesn’t matter as much after the initial installation.\nFor most people, I’d recommend just sticking with Play Store. Play Store isn’t quite flawless, but emphasises the adoption of modern security standards which in turn encourages better privacy practices; as strange as it may sound, Google is not always doing bad things in that regard.\nNote: this article obviously can’t address all the flaws related to Play Store itself. Again, the main topic of this article is about F-Droid and should not be seen as an exhaustive comparison between different app repositories.\nShould I really care?\nIt’s up to your threat model, and of course your personal preferences. Most likely, your phone won’t turn into a nuclear weapon if you install F-Droid on it - and this is far from the point that this article is trying to make. Still, I believe the information presented will be valuable for anyone who values a practical approach to privacy (rather than an ideological one). Such an approach is partially described below.\nBut there is more malware in Play Store! How can you say that it’s more secure?\nAs explained above, it doesn’t matter as you shouldn’t really rely on any quality control to be the sole guarantee that a software is free of malicious or exploitable code. Play Store and even the Apple App Store may have a considerable amount of malware because a full reverse-engineering of any uploaded app isn’t feasible realistically. However, they fulfill their role quite well, and that is all that is expected of them.\nWith Play App Signing being effectively enforced for new apps, isn’t Play Store as “flawed” as F-Droid?\nI’ve seen this comment repeatedly, and it would be dismissing all the other points made in this article. Also, I strongly suggest that you carefully read the sections related to Play App Signing, and preferably the official documentation on this matter. It’s not a black and white question and there are many more nuances to it.\nAren’t open-source apps more secure? Doesn’t it make F-Droid safer?\nYou can still find and get your open-source apps elsewhere. And no, open-source apps aren’t necessarily more private or secure. Instead, you should rely on the strong security and privacy guarantees provided by a modern operating system with a robust sandboxing/permission model, namely modern Android, GrapheneOS and iOS. Pay close attention to the permissions you grant, and avoid legacy apps as they could require invasive permissions to run.\nWhen it comes to trackers (this really comes up a lot), you shouldn’t believe in the flawed idea that you can enumerate all of them. The enumerating badness approach is known to be flawed in the security field, and the same applies to privacy. You shouldn’t believe that a random script can detect every single line of code that can be used for data exfiltration. Data exfiltration can be properly prevented in the first place by the permission model, which again denies access to sensitive data by default: this is a simple, yet rigorous and effective approach.\nNo app should be unnecessarily entrusted with any kind of permission. It is only if you deem it necessary that you should allow access to a type of data, and this access should be as fine-grained as possible. That’s the way the Android platform works (regular apps run in the explicit untrusted_app domain) and continues evolving. Contrary to some popular beliefs, usability and most productivity tasks can still be achieved in a secure and private way.\nIsn’t Google evil? Isn’t Play Store spyware?\nSome people tend to exaggerate the importance of Google in their threat model, at the cost of pragmatism and security/privacy good practices. Play Store isn’t spyware and can run unprivileged like it does on GrapheneOS (including with unattended updates support). On the vast majority of devices though, Google Play is a privileged app and a core part of the OS that provides low-level system modules. In that case, the trust issues involved with Play App Signing could be considered less important since Google Play is already trusted as a privileged component.\nPlay Store evidently has some privacy issues given it’s a proprietary service which requires an account (this cannot be circumvented), and Google services have a history of nagging users to enable privacy-invasive features. Again, some of these privacy issues can be mitigated by setting up the Play services compatibility layer from GrapheneOS which runs Play services and Play Store in the regular app sandbox (the untrusted_app domain). ProtonAOSP also shares that feature. This solution could very well be ported to other Android-based operating systems. If you want to go further, consider using a properly configured account with the least amount of personally indentifiable information possible (note that the phone number requirement appears to be region-dependent).\nIf you don’t have Play services installed, you can use a third-party Play Store client called Aurora Store. Aurora Store has some issues of its own, and some of them overlap in fact with F-Droid. Aurora Store somehow still requires the legacy storage permission, has yet to implement certificate pinning, has been known to sometimes retrieve wrong versions of apps, and distributed account tokens over cleartext HTTP until fairly recently; not that it matters much since tokens were designed to be shared between users, which is already concerning. I’d recommend against using the shared “anonymous” accounts feature: you should make your own throwaway account with minimal information.\nYou should also keep an eye on the great work GrapheneOS does on their future app repository. It will be a simple, secure, modern app repository for a curated list of high-quality apps, some of which will have their own builds (for instance, Signal still uses their original 1024-bits RSA key that has never been rotated since then). Inspired by this work, a GrapheneOS community member is developing a more generic app repository called Accrescent. Hopefully, we’ll see well-made alternatives like these flourish.\nThanks to the GrapheneOS community for proofreading this article. Bear in mind that these are not official recommendations from the GrapheneOS project.\nPost-publication note: it’s unfortunate that the release of this article mostly triggered a negative response from the F-Droid team which prefers to dismiss this article on several occasions rather than bringing relevant counterpoints. Some of their core members are also involved in a harassment campaign towards projects and security researchers that do not share their views. While this article remains a technical one, there are definitely ethical concerns to take into consideration.\n","wordCount":"5298","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","author":{"@type":"Person","name":"Wonderfall"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://privsec.dev/apps/f-droid-security-analysis/"},"publisher":{"@type":"Organization","name":"PrivSec.dev","logo":{"@type":"ImageObject","url":"https://privsec.dev/%3Clink%20/%20abs%20url%3E"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://privsec.dev accesskey=h title="PrivSec.dev (Alt + H)">PrivSec.dev</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://privsec.dev/knowledge/ title="Knowledge Base"><span>Knowledge Base</span></a></li><li><a href=https://privsec.dev/os/ title="Operating Systems"><span>Operating Systems</span></a></li><li><a href=https://privsec.dev/apps/ title=Applications><span>Applications</span></a></li><li><a href=https://privsec.dev/providers/ title=Providers><span>Providers</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://privsec.dev>Home</a>&nbsp;»&nbsp;<a href=https://privsec.dev/apps/>Applications</a></div><h1 class=post-title>F-Droid Security Analysis</h1><div class=post-meta>25 min&nbsp;·&nbsp;5298 words&nbsp;·&nbsp;Wonderfall&nbsp;|&nbsp;<a href=https://github.com/PrivSec-dev/privsec.dev/blob/main/content/apps/F-Droid%20Security%20Analysis.md rel="noopener noreferrer" target=_blank>Suggest Changes</a>
&nbsp;|&nbsp;<span>Originally published at&nbsp;<a href=https://wonderfall.dev/fdroid-issues title=https://wonderfall.dev/fdroid-issues target=_blank rel="noopener noreferrer">wonderfall.dev</a></span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#1-the-trusted-party-problem aria-label="1. The trusted party problem">1. The trusted party problem</a></li><li><a href=#2-slow-and-irregular-updates aria-label="2. Slow and irregular updates">2. Slow and irregular updates</a></li><li><a href=#3-low-target-api-level-sdk-for-client--apps aria-label="3. Low target API level (SDK) for client &amp;amp; apps">3. Low target API level (SDK) for client & apps</a></li><li><a href=#4-general-lack-of-good-practices aria-label="4. General lack of good practices">4. General lack of good practices</a></li><li><a href=#5-confusing-ux aria-label="5. Confusing UX">5. Confusing UX</a></li><li><a href=#6-misleading-permissions-approach aria-label="6. Misleading permissions approach">6. Misleading permissions approach</a></li><li><a href=#conclusion-what-should-you-do aria-label="Conclusion: what should you do?">Conclusion: what should you do?</a></li></ul></div></details></div><div class=post-content><p>F-Droid is a popular alternative app repository for Android, especially known for its main repository dedicated to free and open-source software. F-Droid is often recommended among security and privacy enthusiasts, but how does it stack up against Play Store in practice? This write-up will attempt to emphasize major security issues with F-Droid that you should consider.</p><p>Before we start, a few things to keep in mind:</p><ul><li>The main goal of this write-up was to inform users so they can make responsible choices, not to trash someone else&rsquo;s work. I have respect for any work done in the name of good intentions. Likewise, please don&rsquo;t misinterpret the intentions of this article.</li><li>You have your own reasons for using open-source or free/libre/whatever software which won&rsquo;t be discussed here. A development model shouldn&rsquo;t be an excuse for bad practices and shouldn&rsquo;t lure you into believing that it can provide strong guarantees it cannot.</li><li>A lot of information in this article is sourced from official and trusted sources, but you&rsquo;re welcome to do your own research.</li><li>These analyses do not account for threat models and personal preferences. As the author of this article, I&rsquo;m only interested in facts and not ideologies.</li></ul><p><em>This is not an in-depth security review, nor is it exhaustive.</em></p><h2 id=1-the-trusted-party-problem>1. The trusted party problem<a hidden class=anchor aria-hidden=true href=#1-the-trusted-party-problem>#</a></h2><p>To understand why this is a problem, you&rsquo;ll have to understand a bit about F-Droid&rsquo;s architecture, the things it does very differently from other app repositories, and the <a href=https://arxiv.org/pdf/1904.05572.pdf>Android platform security model</a> (some of the issues listed in this article are somewhat out of the scope of the OS security model, but the majority is).</p><p>Unlike other repositories, F-Droid signs all the apps in the main repository with <strong>its own signing keys</strong> (unique per app) at the exception of the very few <a href=https://f-droid.org/en/docs/Reproducible_Builds/>reproducible builds</a>. A signature is a mathematical scheme that guarantees the authenticity of the applications you download. Upon the installation of an app, Android pins the signature across the entire OS (including user profiles): that&rsquo;s what we call a <em>trust-on-first-use</em> model since all subsequent updates of the app must have the corresponding signature to be installed.</p><p>Normally, the developer is supposed to sign their own app prior to its upload on a distribution channel, whether that is a website or a traditional repository (or both). You don&rsquo;t have to trust the source (usually recommended by the developer) except for the first installation: future updates will have their authenticity cryptographically guaranteed. The issue with F-Droid is that all apps are signed by the same party (F-Droid) which is also not the developer. You&rsquo;re now adding another party you&rsquo;ll have to trust since <strong>you still have to trust the developer</strong> anyway, which isn&rsquo;t ideal: <strong>the fewer parties, the better</strong>.</p><p>On the other hand, Play Store now manages the app signing keys too, as <a href=https://developer.android.com/studio/publish/app-signing#app-signing-google-play>Play App Signing</a> is required for app bundles which are required for new apps since August 2021. These signing keys can be uploaded or automatically generated, and are securely stored by <a href=https://services.google.com/fh/files/misc/security_whitepapers_march2018.pdf>Google Cloud Key Management Service</a>. It should be noted that the developer still has to sign the app with <strong>an upload key</strong> so that Google can verify its authenticity before signing it with the app signing key. For apps created before August 2021 that may have <a href=https://developer.android.com/studio/publish/app-signing#opt-out>not opted in Play App Signing</a> yet, the developer still manages the private key and is responsible for its security, as a compromised private key can allow a third party to sign and distribute malicious code.</p><p>F-Droid requires that the source code of the app is exempt from any proprietary library or ad service, according to their <a href=https://f-droid.org/en/docs/Inclusion_Policy/>inclusion policy</a>. Usually, that means that some developers will have to maintain a slightly different version of their codebase that should comply with F-Droid&rsquo;s requirements. Besides, their &ldquo;quality control&rdquo; offers <strong>close to no guarantees</strong> as having access to the source code doesn&rsquo;t mean it can be easily proofread. Saying Play Store is filled with malicious apps is beyond the point: the <strong>false sense of security</strong> is a real issue. Users should not think of the F-Droid main repository as free of malicious apps, yet unfortunately many are inclined to believe this.</p><blockquote><p>But&mldr; can&rsquo;t I just trust F-Droid and be done with it?</p></blockquote><p><a href=https://forum.f-droid.org/t/is-it-as-safe-as-it-is-from-fdroid-official-repo/15956/12>You don&rsquo;t have to take my word for it</a>: they openly admit themselves it&rsquo;s a <a href=https://forum.f-droid.org/t/is-it-as-safe-as-it-is-from-fdroid-official-repo/15956/2>very basic process</a> relying on badness enumeration (this doesn&rsquo;t work by the way) which consists in a few scripts scanning the code for proprietary blobs and known trackers. You are therefore not exempted from trusting upstream developers and it goes for any repository.</p><p><em>A tempting idea would be to compare F-Droid to the desktop Linux model where users trust their distribution maintainers out-of-the-box (this can be sane if you&rsquo;re already trusting the OS anyway), but the desktop platform is intrinsically chaotic and heterogeneous for better and for worse. It really shouldn&rsquo;t be compared to the Android platform in any way.</em></p><p>While we&rsquo;ve seen that F-Droid controls the signing servers (much like Play App Signing), F-Droid also fully controls the build servers that run the disposable VMs used for building apps. And <a href=https://gitlab.com/groups/fdroid/-/milestones/5#tab-issues>as of July 2022</a>, their guest VM image officially runs a version of Debian which reached EOL. Undoubtedly, this raises questions about their whole infrastructure security.</p><blockquote><p>How can you be sure that the app repository can be held to account for the code it delivers?</p></blockquote><p>F-Droid&rsquo;s answer, interesting yet largely unused, is <a href=https://f-droid.org/en/docs/Reproducible_Builds/>build reproducibility</a>. While deterministic builds are a neat idea in theory, it requires the developer to make their toolchain match with what F-Droid provides. It&rsquo;s additional work on both ends sometimes resulting in <a href=https://code.briarproject.org/briar/briar/-/issues/1612>apps severely lagging behind in updates</a>, so reproducible builds are not as common as we would have wanted. It should be noted that reproducible builds in the main repository can be exclusively developer-signed.</p><p>Google&rsquo;s approach is <a href=https://developer.android.com/guide/app-bundle/code-transparency>code transparency for app bundles</a>, which is a simple idea addressing some of the concerns with Play App Signing. A JSON Web Token (JWT) signed by a key private to the developer is included in the app bundle before its upload to Play Store. This token contains a list of DEX files and native <code>.so</code> libraries and their hashes, allowing end-users to verify that the running code was built and signed by the app developer. Code transparency has known limitations, however: not all resources can be verified, and this verification can only be done manually since it&rsquo;s not part of the Android platform itself (so requiring a code transparency file cannot be enforced by the OS right now). Despite its incompleteness, code transparency is still helpful, easy to implement, and thus something we should see more often as time goes by.</p><blockquote><p>What about other app repositories such as Amazon?</p></blockquote><p><a href=https://developer.amazon.com/docs/app-submission/understanding-submission.html#code_wrapper>To my current knowledge</a>, the Amazon Appstore has always been wrapping APKs with their own code (including their own trackers), and this means they were effectively resigning submitted APKs.</p><p>If you understood correctly the information above, Google can&rsquo;t do this for apps that haven&rsquo;t opted in Play App Signing. As for apps concerned by Play App Signing, while Google could technically introduce their own code like Amazon, they wouldn&rsquo;t do that without telling about it since this will be easily noticeable by the developer and more globally researchers. They have other means on the Android app development platform to do so. Believing they won&rsquo;t do that based on this principle is not a strong guarantee, however: hence the above paragraph about code transparency for app bundles.</p><p>Huawei AppGallery seems to have a <a href=https://developer.huawei.com/consumer/en/doc/distribution/app/20210812>similar approach</a> to Google, where submitted apps could be developer-signed, but newer apps will be resigned by Huawei.</p><h2 id=2-slow-and-irregular-updates>2. Slow and irregular updates<a hidden class=anchor aria-hidden=true href=#2-slow-and-irregular-updates>#</a></h2><p>Since you&rsquo;re adding one more party to the mix, that party is now responsible for delivering proper builds of the app: it&rsquo;s a common thing among traditional Linux distributions and their packaging system. They have to catch up with <em>upstream</em> on a regular basis, but very few do it well (Arch Linux comes to my mind). Others, like Debian, prefer making extensive <em>downstream</em> changes and delivering security fixes for a subset of vulnerabilities assigned to a CVE (yeah, it&rsquo;s as bad as it sounds, but that&rsquo;s another topic).</p><p>Not only does F-Droid require specific changes for the app to comply with its inclusion policy, which often leads to more maintenance work, it also has a rather strange way of triggering new builds. Part of its build process seems to be <a href=https://f-droid.org/en/docs/FAQ_-_App_Developers/>automated</a>, which is the least you could expect. Now here&rsquo;s the thing: app signing keys are on an <strong>air-gapped server</strong> (meaning it&rsquo;s disconnected from any network, at least that&rsquo;s what they claim: see <a href=https://f-droid.org/docs/Building_a_Signing_Server/>their recommendations</a> for reference), which forces an irregular update cycle where a human has to manually trigger the signing process. It is far from an ideal situation, and you may argue it&rsquo;s the least to be expected since by entrusting all the signing keys to one party, you could also introduce a single point of failure. Should their system be compromised (whether from the inside or the outside), this could lead to serious security issues affecting plenty of users.</p><p><em>This is one of the main reasons why Signal refused to support the inclusion of a third-party build in the F-Droid official repository. While <a href=https://github.com/signalapp/Signal-Android/issues/127>this GitHub issue</a> is quite old, many points still hold true today.</em></p><p>Considering all this, and the fact that their build process is often broken using outdated tools, you have to expect <strong>far slower updates</strong> compared to a traditional distribution system. Slow updates mean that you will be exposed to security vulnerabilities more often than you should&rsquo;ve been. It would be unwise to have a full browser updated through the F-Droid official repository, for instance. F-Droid third-party repositories somewhat mitigate the issue of slow updates since they can be managed directly by the developer. It isn&rsquo;t ideal either as you will see below.</p><h2 id=3-low-target-api-level-sdk-for-client--apps>3. Low target API level (SDK) for client & apps<a hidden class=anchor aria-hidden=true href=#3-low-target-api-level-sdk-for-client--apps>#</a></h2><p>SDK stands for <em>Software Development Kit</em> and is the collection of software to build apps for a given platform. On Android, a higher SDK level means you&rsquo;ll be able to make use of modern API levels of which each iteration brings <strong>security and privacy improvements</strong>. For instance, API level 31 makes use of all these improvements on Android 12.</p><p>As you may already know, Android has a strong sandboxing model where each application is sandboxed. You could say that an app compiled with the highest API level benefits from all the latest improvements brought to the app sandbox; as opposed to outdated apps compiled with older API levels, which have a <strong>weaker sandbox</strong>.</p><pre tabindex=0><code># b/35917228 - /proc/misc access
# This will go away in a future Android release
allow untrusted_app_25 proc_misc:file r_file_perms;

# Access to /proc/tty/drivers, to allow apps to determine if they
# are running in an emulated environment.
# b/33214085 b/33814662 b/33791054 b/33211769
# https://github.com/strazzere/anti-emulator/blob/master/AntiEmulator/src/diff/strazzere/anti/emulator/FindEmulator.java
# This will go away in a future Android release
allow untrusted_app_25 proc_tty_drivers:file r_file_perms;
</code></pre><p>This is a mere sample of the <a href=https://android.googlesource.com/platform/system/sepolicy/+/refs/tags/android-12.0.0_r21/private>SELinux exceptions</a> that have to be made on older API levels so that you can understand why it matters.</p><p>It turns out the official F-Droid client doesn&rsquo;t care much about this since it lags behind quite a bit, <strong><a href=https://gitlab.com/fdroid/fdroidclient/-/blob/2a8b16683a2dbee16d624a58e7dd3ea1da772fbd/app/build.gradle#L33>targeting the API level 25</a></strong> (Android 7.1) of which some SELinux exceptions were shown above. As a workaround, some users recommended third-party clients such as <a href=https://f-droid.org/en/packages/nya.kitsunyan.foxydroid/>Foxy Droid</a> or <a href=https://f-droid.org/en/packages/com.aurora.adroid/>Aurora Droid</a>. While these clients might be technically better, they&rsquo;re poorly maintained for some, and they also introduce yet another party to the mix. <a href=https://github.com/Iamlooker/Droid-ify>Droid-ify</a> (recently rebreanded to Neo-Store) seems to be a better option than the official client in most aspects.</p><p>Furthermore, F-Droid <strong>doesn&rsquo;t enforce a minimum target SDK</strong> for the official repository. Play Store <a href=https://developer.android.com/google/play/requirements/target-sdk>does that quite aggressively</a> for new apps and app updates:</p><ul><li>Since August 2021, Play Store requires new apps to target at least API level 30.</li><li>Since November 2021, existing apps must at least target API level 30 for updates to be submitted.</li></ul><p>While it may seem bothersome, it&rsquo;s a necessity to keep the <strong>app ecosystem modern and healthy</strong>. Here, F-Droid sends the wrong message to developers (and even users) because they should care about it, and this is why many of us think it may be even harmful to the FOSS ecosystem. Backward compatibility is often the enemy of security, and while there&rsquo;s a middle-ground for convenience and obsolescence, it shouldn&rsquo;t be exaggerated. As a result of this philosophy, the main repository of F-Droid is filled with obsolete apps from another era, just for these apps to be able to run on the more than ten years old Android 4.0 Ice Cream Sandwich. Let&rsquo;s not make the same mistake as the desktop platforms: instead, complain to your vendors for selling devices with no decent OS/firmware support.</p><p>There is little practical reason for developers not to increase the target SDK version (<code>targetSdkVersion</code>) along with each Android release. This attribute matches the version of the platform an app is targeting, and allows access to modern improvements, rules and features on a modern OS. The app can still ensure backwards compatibility in such a way that it can run on older platforms: the <code>minSdkVersion</code> attribute informs the system about the minimum API level required for the application to run. Setting it too low isn&rsquo;t practical though, because this requires having a lot of fallback code (most of it is handled by common libraries) and separate code paths.</p><p>At the time of writing:</p><ul><li>Android 9 is the oldest Android version that is <a href=https://endoflife.date/android>getting security updates</a>.</li><li><a href=https://developer.android.com/about/dashboards>~80% of the Android devices</a> used in the world are <strong>at least</strong> running 8.0 Oreo.</li></ul><p><em>Overall statistics do not reflect real-world usage of a given app (people using old devices are not necessarily using your app). If anything, it should be viewed as an underestimation.</em></p><h2 id=4-general-lack-of-good-practices>4. General lack of good practices<a hidden class=anchor aria-hidden=true href=#4-general-lack-of-good-practices>#</a></h2><p>The F-Droid client allows multiple repositories to coexist within the same app. Many of the issues highlighted above were focused on the main official repository which most of the F-Droid users will use anyway. However, having <strong>other repositories in a single app also violates the security model of Android</strong> which was not designed for this at all. The OS expects you to trust <strong>an app repository as a single source</strong> of apps, yet F-Droid isn&rsquo;t that by design as it mixes several repositories in one single app. This is important because the OS management APIs and features (such as <a href=https://developer.android.com/reference/android/os/UserManager>UserManager</a>) are not meant for this and see F-Droid as a single source, so you&rsquo;re trusting the app client to not mess up far more than you should, especially when the privileged extension comes into the picture. This is also a problem with the OS first-party source feature.</p><p>On that note, it is also worth noting the repository metadata format isn&rsquo;t properly signed by lacking whole-file signing and key rotation. <a href=https://f-droid.org/2021/02/05/apis-for-all-the-things.html#the-repo-index>Their index v1</a> format <a href=https://gitlab.com/fdroid/fdroidserver/-/blob/3182b77d180b2313f4fdb101af96c035380abfd7/fdroidserver/signindex.py>uses JAR signing</a> with <code>jarsigner</code>, which has serious security flaws. It seems that <a href=https://gitlab.com/fdroid/fdroidserver/-/commit/3182b77d180b2313f4fdb101af96c035380abfd7>work is in progress on a v2 format</a> with support for <code>apksigner</code>, although the final implementation remains to be seen. This just seems to be an over-engineered and flawed approach since better suited tools such as <code>signify</code> could be used to sign the metadata JSON.</p><p>As a matter of fact, the <a href=https://developer.android.com/reference/android/Manifest.permission#UPDATE_PACKAGES_WITHOUT_USER_ACTION>new unattended update API</a> added in API level 31 (Android 12) that allows seamless app updates for app repositories without <a href=https://f-droid.org/en/packages/org.fdroid.fdroid.privileged/>privileged access</a> to the system (such an approach is not compatible with the security model) won&rsquo;t work with F-Droid &ldquo;as is&rdquo;. It should be mentioned that the aforementioned third-party client <a href=https://github.com/Iamlooker/Droid-ify/issues/20>Neo-Store</a> supports this API, although the underlying issues about the F-Droid infrastructure largely remain. Indeed, this secure API allowing for unprivileged unattended updates not only requires for the app repository client to target API level 31, but the apps to be updated also have to at least target API level 29.</p><p>Their client also lacks <strong>TLS certificate pinning</strong>, unlike Play Store which improves security for all connections to Google (they generally use a limited set of root CAs including <a href=https://pki.goog/>their own</a>). Certificate pinning is a way for apps to increase the security of their connection to services <a href=https://developer.android.com/training/articles/security-config#CertificatePinning>by providing a set of public key hashes</a> of known-good certificates for these services instead of trusting pre-installed CAs. This can avoid some cases where an interception (<em>man-in-the-middle</em> attack) could be possible and lead to various security issues considering you&rsquo;re trusting the app to deliver you other apps.</p><p>It is an important security feature that is also straightforward to implement using the <a href=https://developer.android.com/training/articles/security-config>declarative network security configuration</a> available since Android 7.0 (API level 24). See how GrapheneOS pins both root and CA certificates in their <a href=https://github.com/GrapheneOS/Apps>app repository client</a>:</p><pre tabindex=0><code>&lt;!-- res/xml/network_security_config.xml --&gt;
&lt;network-security-config&gt;
    &lt;base-config cleartextTrafficPermitted=&#34;false&#34;/&gt;
    &lt;domain-config&gt;
        &lt;domain includeSubdomains=&#34;true&#34;&gt;apps.grapheneos.org&lt;/domain&gt;
        &lt;pin-set&gt;
            &lt;!-- ISRG Root X1 --&gt;
            &lt;pin digest=&#34;SHA-256&#34;&gt;C5+lpZ7tcVwmwQIMcRtPbsQtWLABXhQzejna0wHFr8M=&lt;/pin&gt;
            &lt;!-- ISRG Root X2 --&gt;
            &lt;pin digest=&#34;SHA-256&#34;&gt;diGVwiVYbubAI3RW4hB9xU8e/CH2GnkuvVFZE8zmgzI=&lt;/pin&gt;
            &lt;!-- Let&#39;s Encrypt R3 --&gt;
            &lt;pin digest=&#34;SHA-256&#34;&gt;jQJTbIh0grw0/1TkHSumWb+Fs0Ggogr621gT3PvPKG0=&lt;/pin&gt;
            &lt;!-- Let&#39;s Encrypt E1 --&gt;
            &lt;pin digest=&#34;SHA-256&#34;&gt;J2/oqMTsdhFWW/n85tys6b4yDBtb6idZayIEBx7QTxA=&lt;/pin&gt;
            ...
        &lt;/pin-set&gt;
    &lt;/domain-config&gt;
&lt;/network-security-config&gt;
</code></pre><p>To be fair, they&rsquo;ve thought several times about adding certificate pinning to their client <a href=https://gitlab.com/fdroid/fdroidclient/-/issues/105>at least for the default repositories</a>. <a href=https://gitlab.com/fdroid/fdroidclient/-/blob/1.14-alpha4/app/src/main/java/org/fdroid/fdroid/FDroidCertPins.java>Relics of preliminary work</a> can even be found in their current codebase, but it&rsquo;s unfortunate that they haven&rsquo;t been able to find <a href=https://github.com/f-droid/fdroidclient/commit/7f78b46664981b9b73cadbfdda6391f6fe939c77>any working implementation</a> so far. Given the overly complex nature of F-Droid, that&rsquo;s largely understandable.</p><p>F-Droid also has a problem regarding the adoption of <strong><a href=https://source.android.com/security/apksigning>new signature schemes</a></strong> as they <a href=https://forum.f-droid.org/t/why-f-droid-is-still-using-apk-signature-scheme-v1/10602>held out on the v1 signature scheme</a> (which was <a href=https://www.xda-developers.com/janus-vulnerability-android-apps/>horrible</a> and deprecated since 2017) until they were forced by Android 11 requirements to support the newer v2/v3 schemes (v2 was introduced in Android 7.0). Quite frankly, this is straight-up bad, and <strong>signing APKs with GPG</strong> is no better considering <a href=https://latacora.micro.blog/2019/07/16/the-pgp-problem.html>how bad PGP and its reference implementation GPG are</a> (even Debian <a href=https://wiki.debian.org/Teams/Apt/Spec/AptSign>is trying to move away from it</a>). Ideally, F-Droid should fully move on to newer signature schemes, and should completely phase out the legacy signature schemes which are still being used for some apps and metadata.</p><h2 id=5-confusing-ux>5. Confusing UX<a hidden class=anchor aria-hidden=true href=#5-confusing-ux>#</a></h2><p>It is worth mentioning that their website has (for some reason) always been hosting an <a href=https://forum.f-droid.org/t/why-does-the-f-droid-website-nearly-always-host-an-outdated-f-droid-apk/6234>outdated APK of F-Droid</a>, and this is still the case today, leading to many users wondering why they can&rsquo;t install F-Droid on their secondary user profile (due to the downgrade prevention enforced by Android). &ldquo;Stability&rdquo; seems to be the main reason mentioned on their part, which doesn&rsquo;t make sense: either your version isn&rsquo;t ready to be published in a stable channel, or it is and new users should be able to access it easily.</p><p>F-Droid should enforce the approach of prefixing the package name of their alternate builds with <code>org.f-droid</code> for instance (or add a <code>.fdroid</code> suffix as some already have). Building and signing while <strong>reusing the package name</strong> (<a href=https://developer.android.com/studio/build/configure-app-module>application ID</a>) is bad practice as it causes <strong>signature verification errors</strong> when some users try to update/install these apps from other sources, even directly from the developer. That is again due to the security model of Android which enforces a signature check when installing app updates (or installing them again in a secondary user profile). Note that this is going to be an issue with Play App Signing as well, and developers are encouraged to follow this approach should they intend to distribute their apps through different distribution channels.</p><p>This results in a confusing user experience where it&rsquo;s hard to keep track of who signs each app, and from which repository the app should be downloaded or updated.</p><h2 id=6-misleading-permissions-approach>6. Misleading permissions approach<a hidden class=anchor aria-hidden=true href=#6-misleading-permissions-approach>#</a></h2><p>F-Droid shows a list of the <a href=https://developer.android.com/reference/android/Manifest.permission>low-level permissions</a> for each app: these low-level permissions are usually grouped in the standard high-level permissions (Location, Microphone, Camera, etc.) and special toggles (nearby Wi-Fi networks, Bluetooth devices, etc.) that are explicitly based on a type of sensitive data. While showing a list of low-level permissions could be useful information for a developer, it&rsquo;s often a <strong>misleading</strong> and inaccurate approach for the end-user. Since Android 6, apps have to <a href=https://developer.android.com/guide/topics/permissions/overview#runtime>request the standard permissions at runtime</a> and do not get them simply by being installed, so showing all the &ldquo;under the hood&rdquo; permissions without proper context is not useful and makes the permission model unnecessarily confusing.</p><p>F-Droid claims that these low-level permissions are relevant because they support Android 5.1+, meaning they support very outdated versions of Android where apps could have <a href=https://source.android.com/devices/tech/config/runtime_perms>install-time permissions</a>. Anyway, if a technical user wants to see all the manifest permissions for some reason, then they can access the app manifest pretty easily (in fact, exposing the raw manifest would be less misleading). But this is already beyond the scope of this article because anyone who cares about privacy and security wouldn&rsquo;t run a 8 years old version of Android that has not received security updates for years.</p><p><em>To clear up confusion: even apps targeting an API level below 23 (Android 5.1 or older) do not have permissions granted at install time on modern Android, which instead displays a legacy permission grant dialog. Whether or not permissions are granted at install time does not just depend on the app&rsquo;s <code>targetSdkVersion</code>. And even if this were the case, the OS package installer on modern Android would&rsquo;ve been designed to show the requested permissions for those legacy apps.</em></p><p>For example, the low-level permission <code>RECEIVE_BOOT_COMPLETED</code> is referred to in F-Droid as the <em>run at startup</em> description, when in fact this permission is not needed to start at boot and just refers to a specific time broadcasted by the system once it finishes booting, and is not about background usage (though power usage may be a valid concern). To be fair, these short summaries used to be provided by the Android documentation years ago, but the permission model has drastically evolved since then and most of them aren&rsquo;t accurate anymore.</p><blockquote><p><em>Allows the app to have itself started as soon as the system has finished booting. This can make it take longer to start the phone and allow the app to slow down the overall phone by always running.</em></p></blockquote><p>In modern Android, the background restriction toggle is what really provides the ability for apps to run in the background. Some low-level permissions don&rsquo;t even have a security/privacy impact and shouldn&rsquo;t be misinterpreted as having one. Anyhow, you can be sure that each dangerous low-level permission has a <strong>high-level representation</strong> that is <strong>disabled by default</strong> and needs to be <strong>granted dynamically</strong> to the app (by a toggle or explicit user consent in general).</p><p>Another example to illustrate the shortcomings of this approach would be the <code>QUERY_ALL_PACKAGES</code> low-level permission, which is referred to as the <em>query all packages</em> permission that &ldquo;allows an app to see all installed packages&rdquo;. While this is somewhat correct, this can also be misleading: apps do not need <code>QUERY_ALL_PACKAGES</code> to list other apps within the same user profile. Even without this permission, some apps are visible automatically (visibility is restricted by default <a href=https://developer.android.com/training/package-visibility>since Android 11</a>). If an app needs more visibility, it will declare a <code>&lt;queries></code> element in its manifest file: in other words, <code>QUERY_ALL_PACKAGES</code> is only one way to achieve visibility. Again, this goes to show low-level manifest permissions are not intended to be interpreted as high-level permissions the user should fully comprehend.</p><p>Moreover, <a href=https://support.google.com/googleplay/android-developer/answer/9888170>Play Store restricts the use of highly invasive permissions</a> such as <code>MANAGE_EXTERNAL_STORAGE</code> which allows apps to opt out of scoped storage if they can&rsquo;t work with <a href=https://developer.android.com/guide/topics/providers/document-provider>more privacy friendly approaches</a> (like a file explorer). Apps that can&rsquo;t justify their use of this permission (which again has to be granted dynamically) may be removed from Play Store. This is where an app repository can actually be useful in their review process to protect end-users from installing poorly made apps that might compromise their privacy. Not that it matters much if these apps target very old API levels that are inclined to require invasive permissions in the first place&mldr;</p><h2 id=conclusion-what-should-you-do>Conclusion: what should you do?<a hidden class=anchor aria-hidden=true href=#conclusion-what-should-you-do>#</a></h2><p>So far, you have been presented with referenced facts that are easily verifiable. In the next part, I&rsquo;ll allow myself to express my own thoughts and opinions. You&rsquo;re free to disagree with them, but don&rsquo;t let that overshadow the rest.</p><p>While some improvements could easily be made, I don&rsquo;t think F-Droid is in an ideal situation to solve all of these issues because some of them are <strong>inherent flaws</strong> in their architecture. I&rsquo;d also argue that their core philosophy is not aligned with some security principles expressed in this article. In any case, I can only wish for them to improve since they&rsquo;re one of the most popular alternatives to commercial app repositories, and are therefore trusted by a large userbase.</p><p>F-Droid is often seen as the only way to get and support open-source apps: that is not the case. Sure, F-Droid could help you in finding FOSS apps that you wouldn&rsquo;t otherwise have known existed. Many developers also publish their FOSS apps on the <strong>Play Store</strong> or their website directly. Most of the time, releases are available on <strong>GitHub</strong>, which is great since each GitHub releases page has an Atom feed. If downloading APKs from regular websites, you can use <code>apksigner</code> to validate the authenticity by comparing the certificate fingerprint against the fingerprint from another source (it wouldn&rsquo;t matter otherwise).</p><p>This is how you may proceed to get the app certificate:</p><pre tabindex=0><code>apksigner verify --print-certs --verbose myCoolApp.apk
</code></pre><p>Also, as written above: the OS pins the app signature (for all profiles) upon installation, and enforces signature check for app updates. In practice, this means the source doesn&rsquo;t matter as much after the initial installation.</p><p>For most people, I&rsquo;d recommend just <strong>sticking with Play Store</strong>. Play Store isn&rsquo;t quite flawless, but emphasises the adoption of modern security standards which in turn encourages better privacy practices; as strange as it may sound, Google is not always doing bad things in that regard.</p><p><em>Note: this article obviously can&rsquo;t address all the flaws related to Play Store itself. Again, the main topic of this article is about F-Droid and should not be seen as an exhaustive comparison between different app repositories.</em></p><blockquote><p>Should I really care?</p></blockquote><p><strong>It&rsquo;s up to your threat model</strong>, and of course your personal preferences. Most likely, your phone won&rsquo;t turn into a nuclear weapon if you install F-Droid on it - and this is far from the point that this article is trying to make. Still, I believe the information presented will be valuable for anyone who values a <strong>practical approach to privacy</strong> (rather than an ideological one). Such an approach is partially described below.</p><blockquote><p>But there is more malware in Play Store! How can you say that it&rsquo;s more secure?</p></blockquote><p>As explained above, it doesn&rsquo;t matter as you shouldn&rsquo;t really rely on any quality control to be the sole guarantee that a software is free of malicious or exploitable code. Play Store and even the Apple App Store may have a considerable amount of malware because a full reverse-engineering of any uploaded app isn&rsquo;t feasible realistically. However, they fulfill their role quite well, and that is all that is expected of them.</p><blockquote><p>With Play App Signing being effectively enforced for new apps, isn&rsquo;t Play Store as &ldquo;flawed&rdquo; as F-Droid?</p></blockquote><p>I&rsquo;ve seen this comment repeatedly, and it would be dismissing all the other points made in this article. Also, I strongly suggest that you carefully read the sections related to Play App Signing, and preferably the official documentation on this matter. It&rsquo;s not a black and white question and there are many more nuances to it.</p><blockquote><p>Aren&rsquo;t open-source apps more secure? Doesn&rsquo;t it make F-Droid safer?</p></blockquote><p>You can still find and get your open-source apps elsewhere. And no, open-source apps <a href=https://seirdy.one/2022/02/02/floss-security.html>aren&rsquo;t necessarily more private or secure</a>. Instead, you should rely on the strong security and privacy guarantees provided by a modern operating system with <strong>a robust sandboxing/permission model</strong>, namely modern Android, GrapheneOS and iOS. Pay close attention to the permissions you grant, and avoid legacy apps as they could require invasive permissions to run.</p><p>When it comes to <em>trackers</em> (this really comes up a lot), you shouldn&rsquo;t believe in the flawed idea that you can enumerate all of them. The <em>enumerating badness</em> approach is <a href=https://www.ranum.com/security/computer_security/editorials/dumb/>known to be flawed in the security field</a>, and the same applies to privacy. You shouldn&rsquo;t believe that a random script can detect every single line of code that can be used for data exfiltration. Data exfiltration can be properly prevented in the first place by the permission model, which again <strong>denies access to sensitive data by default</strong>: this is a simple, yet rigorous and effective approach.</p><p>No app should be unnecessarily entrusted with any kind of permission. It is only if you deem it necessary that you should allow access to a type of data, and this access should be as fine-grained as possible. That&rsquo;s the way the Android platform works (regular apps run in the explicit <code>untrusted_app</code> domain) and continues evolving. Contrary to some popular beliefs, usability and most productivity tasks can still be achieved in a secure and private way.</p><blockquote><p>Isn&rsquo;t Google evil? Isn&rsquo;t Play Store spyware?</p></blockquote><p>Some people tend to exaggerate the importance of Google in their threat model, at the cost of pragmatism and security/privacy good practices. Play Store isn&rsquo;t spyware and can run unprivileged like it does on GrapheneOS (including with unattended updates support). On the vast majority of devices though, Google Play is a privileged app and a core part of the OS that provides low-level system modules. In that case, the trust issues involved with Play App Signing could be considered less important since Google Play is already trusted as a privileged component.</p><p><strong>Play Store evidently has some privacy issues</strong> given it&rsquo;s a proprietary service which requires an account (this cannot be circumvented), and Google services have a history of nagging users to enable privacy-invasive features. Again, some of these privacy issues can be mitigated by setting up the <a href=https://grapheneos.org/usage#sandboxed-google-play>Play services compatibility layer from GrapheneOS</a> which runs Play services and Play Store in the regular app sandbox (the <code>untrusted_app</code> domain). <a href=https://protonaosp.org/features#privacy-and-security>ProtonAOSP also shares that feature</a>. This solution could very well be ported to other Android-based operating systems. If you want to go further, consider using a properly configured account with the least amount of personally indentifiable information possible (note that the phone number requirement appears to be region-dependent).</p><p>If you don&rsquo;t have Play services installed, you can use a third-party Play Store client called <strong><a href=https://auroraoss.com/>Aurora Store</a></strong>. Aurora Store has some issues of its own, and some of them overlap in fact with F-Droid. Aurora Store somehow still requires <a href=https://gitlab.com/AuroraOSS/AuroraStore/-/blob/26f5d4fd558263a89baee4c3cbe1d220913da104/app/src/main/AndroidManifest.xml#L28-32>the legacy storage permission</a>, has yet to <a href=https://gitlab.com/AuroraOSS/AuroraStore/-/issues/697>implement certificate pinning</a>, has been known to sometimes retrieve wrong versions of apps, and <a href=https://gitlab.com/AuroraOSS/AuroraStore/-/issues/722>distributed account tokens</a> over <a href=https://gitlab.com/AuroraOSS/AuroraStore/-/issues/734>cleartext HTTP</a> until fairly recently; not that it matters much since tokens were designed to be shared between users, which is already concerning. I&rsquo;d recommend against using the shared &ldquo;anonymous&rdquo; accounts feature: you should make your own throwaway account with minimal information.</p><p>You should also keep an eye on the great work <strong>GrapheneOS</strong> does on <a href=https://github.com/GrapheneOS/Apps>their future app repository</a>. It will be a simple, secure, modern app repository for a curated list of high-quality apps, some of which will have their own builds (for instance, Signal still uses their <a href=https://github.com/signalapp/Signal-Android/issues/9362>original 1024-bits RSA key</a> that has never been rotated since then). Inspired by this work, a GrapheneOS community member is developing a more generic app repository called <a href=https://twitter.com/lberrymage/status/1475307653089792003>Accrescent</a>. Hopefully, we&rsquo;ll see well-made alternatives like these flourish.</p><p><em>Thanks to the GrapheneOS community for proofreading this article. Bear in mind that these are not official recommendations from the GrapheneOS project.</em></p><p><em>Post-publication note: it&rsquo;s unfortunate that the release of this article mostly triggered a negative response from the F-Droid team which prefers to dismiss this article on several occasions rather than bringing relevant counterpoints. Some of their core members are also involved in a harassment campaign towards projects and security researchers that do not share their views. While this article remains a technical one, there are definitely ethical concerns to take into consideration.</em></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://privsec.dev/tags/software/>software</a></li><li><a href=https://privsec.dev/tags/android/>android</a></li><li><a href=https://privsec.dev/tags/security/>security</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://privsec.dev>PrivSec.dev</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>